"""
Path traversal demo (local-only).

This shows:
- a vulnerable function that naively concatenates an input filename to a directory path (VULN)
- a safe function that resolves and checks the final path using secure join and canonicalization
"""

import os

BASE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), "files"))
os.makedirs(BASE_DIR, exist_ok=True)

# create a sample file for demo
with open(os.path.join(BASE_DIR, "readme.txt"), "w") as f:
    f.write("This is a local demo file.\n")


def read_file_vuln(filename: str) -> str:
    """
    VULN: naive concatenation allows traversal such as ../../etc/passwd (if allowed).
    This demo runs in a sandboxed repo and does not access system paths by default,
    but the pattern is intentionally unsafe if used with user-controlled values.
    """
    path = os.path.join(BASE_DIR, filename)
    with open(path, "r", encoding="utf-8") as fh:
        return fh.read()


def read_file_safe(filename: str) -> str:
    """
    SAFE: prevent traversal by resolving the absolute path and ensuring it is under BASE_DIR.
    """
    requested = os.path.normpath(os.path.join(BASE_DIR, filename))
    # Ensure the requested path starts with BASE_DIR
    if not requested.startswith(BASE_DIR):
        raise ValueError("Invalid filename/path")
    with open(requested, "r", encoding="utf-8") as fh:
        return fh.read()


def run(safe_mode=True):
    print("Path traversal demo (local-only).")
    fname = input("Enter filename to read (example: readme.txt): ").strip()
    try:
        if safe_mode:
            print("SAFE read:")
            print(read_file_safe(fname))
        else:
            print("VULN read (demonstration only):")
            print(read_file_vuln(fname))
    except Exception as e:
        print("Error:", e)
